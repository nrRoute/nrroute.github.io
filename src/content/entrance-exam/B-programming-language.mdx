---
title: プログラミング言語まとめ
created: 2025-07-31
tags:
- programming-language
- summary
modified: 2025-08-01
---

# プログラミング言語

時間がないのでGPTに出力させた。

**型（200字程度）**

プログラミング言語における型とは、値や式が取り得るデータ集合と、その上で許可される演算を規定するメタ情報である。型システムは変数・関数の入出力・式の結果に整合性を課し、誤用をコンパイル時または実行時に検出する。静的型付けは実行前に安全性と最適化余地を与え、コードの自己文書化にも寄与する。一方、動的型付けは柔軟性を高め、実行時の型タグで安全性を担保する。
（全文約200字）

**スタックオーバーフロー（200字程度）**

スタックオーバーフローとは、関数呼び出しや自動変数の格納に使われる実行時スタック領域が上限を超えて書き込まれ、保護ページに達した結果発生する例外である。原因は深すぎる再帰、多量の自動配列、呼び出しループなど。発生時には OS がガードページへのアクセス違反を検知し、プロセスは SIGSEGV などのシグナルで異常終了する。未定義領域への上書きにより、クラッシュだけでなく任意コード実行の脆弱性となる場合もある。
（全文約200字）

## 末尾再帰関数

再帰関数での再起呼び出しがすべて末尾呼び出しになっている関数。

## カリー化

関数を返す関数（高階関数）を使って、引数をまとめて受け取る関数を、一つずつ受け取る関数にできる。

https://hackmd.io/@aigarashi/r1az0wOHP/%2F8YzCGhsMTQOTk8Zg_ajktQ

# 言語処理系

## LL(1) 文法

Left-to-right parse Leftmost-derivation with 1-symbol lookahead Grammer。つまり、左から見ていって、1文字先読みして最左導出をする。

### 判定

ざっくりいうと、Nulls、FIRST、FOLLOWを計算して、解析表を作る。解析表で衝突が起こったら、LL(1)ではない。

Nullsは、空文字を生成しうる非終端記号の集合。
FIRSTは、ある非終端記号Xについて、Xから生成される語の先頭文字の集合。
FOLLOWは、ある非終端記号Xについて、Xの次に続きうる終端記号の集合。

### Nulls、FIRST、FOLLOWの計算

Nullsは、各書き換え規則 $X \to Y_1 \dots Y_n$ に対して（$Y_i$ は終端・非終端記号）、

$$
\def\nulls{\text{Nulls}}
Y_1\in \nulls \land \dots \land Y_n \in \nulls \implies X\in \nulls
$$

であれば、XをNullsに追加する。

FIRST(X)は、各書き換え規則 $X \to Y_1 \dots Y_n$ および $k=1,...,n$ に対して（$Y_i$ は終端・非終端記号）、

$$
\def\nulls{\text{Nulls}}
Y_1\in \nulls \land \dots \land Y_{k-1}\in \nulls\implies \text{FIRST}(X) \supseteq \text{FIRST}(Y_k)
$$

であれば、要素を追加[^1]。

FOLLOW(X)は、各書き換え規則 $X \to Y_1 \dots Y_n$ に対して（$Y_i$ は終端・非終端記号）、

$$
\def\nulls{\text{Nulls}}
Y_{k+1}\in \nulls \land \dots \land Y_{m-1}\in \nulls \implies \text{FOLLOW}(Y_k)\supseteq\text{FIRST}(Y_m)~(1\le k\lt m\le n)
$$
$$
\def\nulls{\text{Nulls}}
Y_{k+1}\in \nulls \land \dots \land Y_{n}\in \nulls \implies \text{FOLLOW}(Y_k)\supseteq\text{FOLLOW}(X)~(1\le k\le n)
$$

であれば、要素を追加。

## LL(1) 言語

まず、LL(1)文法から生成される言語はLL(1)言語。しかし、LL(1)文法でなくてもLL(1)言語となる場合もある。

[^1]: $Y$の添字が$k-1$であることに注意。$n=1$のときはならばの仮定がなくなるので結論が成り立ち、$Y_1$が追加される。

## インタプリタ実装

インタプリタ実装のためのコード片を載せておく。データの定義は `syntax.ml` みたいな感じ。

```ocaml title="syntax.ml"
(* id *)
type id = string

(* 演算子 *)
type binOp = Plus | Mult | Lt | And | Or

(* 式 *)
type exp =
  | Var of id
  | ILit of int
  | BLit of bool
  | BinOp of binOp * exp * exp
  | IfExp of exp * exp * exp
  | LetExp of id * exp * exp

(* 値 *)
type exval =
  | IntV of int
  | BoolV of bool

(* 環境 *)
type environment = (id * exval) list

(* 例外 *)
exception Error of string
```

評価器のコードはこんな感じ。

```ocaml title="eval.ml"
let rec find x env =
  match env with
  | [] -> raise (Error (x ^ "was not found in the environment."))
  | (id, v) :: t -> if id = x then v else find x t

(* 式の評価 *)
let rec eval env = function
  | ILit i -> IntV i
  | BLit b -> BoolV b
  | Var x -> find x env (* 環境からxに束縛された値を探す *)
  | IfExp (e, e1, e2) ->
    let test = eval env e in
    match test with
    | BoolV true -> eval env e1
    | BoolV false -> eval env e2
    | _ -> raise (Error ("test must be bool."))
  | LetExp (id, e1, e2) ->
    let v1 = eval env e1 in
    let newenv = (id, v1) :: env in
    eval newenv e2;;
```

# 計算と論理

## 型付きラムダ計算

カッコの有無に注意。

## 自然演繹

$\bot$ が示したい命題に入っていたら、$\Gamma \vdash \bot$ を何らかの手段で作る。大抵は爆発則 $\bot E$ から作る。
ORの導入規則 $\lor I$ はすぐには使わない。
