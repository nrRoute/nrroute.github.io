---
title: プログラミング言語まとめ
created: 2025-07-31
tags:
- programming-language
- guide
---

# 言語処理系

## LL(1) 文法

Left-to-right parse Leftmost-derivation with 1-symbol lookahead Grammer。つまり、左から見ていって、1文字先読みして最左導出をする。

### 判定

ざっくりいうと、Nulls、FIRST、FOLLOWを計算して、解析表を作る。解析表で衝突が起こったら、LL(1)ではない。

Nullsは、空文字を生成しうる非終端記号の集合。
FIRSTは、ある非終端記号Xについて、Xから生成される語の先頭文字の集合。
FOLLOWは、ある非終端記号Xについて、Xの次に続きうる終端記号の集合。

### Nulls、FIRST、FOLLOWの計算

Nullsは、各書き換え規則 $X \to Y_1 \dots Y_n$ に対して（$Y_i$ は終端・非終端記号）、

$$
\def\nulls{\text{Nulls}}
Y_1\in \nulls \land \dots \land Y_n \in \nulls \implies X\in \nulls
$$

であれば、XをNullsに追加する。

FIRST(X)は、各書き換え規則 $X \to Y_1 \dots Y_n$ および $k=1,...,n$ に対して（$Y_i$ は終端・非終端記号）、

$$
\def\nulls{\text{Nulls}}
Y_1\in \nulls \land \dots \land Y_{k-1}\in \nulls\implies \text{FIRST}(X) \supseteq \text{FIRST}(Y_k)
$$

であれば、要素を追加[^1]。

FOLLOW(X)は、各書き換え規則 $X \to Y_1 \dots Y_n$ に対して（$Y_i$ は終端・非終端記号）、

$$
\def\nulls{\text{Nulls}}
Y_{k+1}\in \nulls \land \dots \land Y_{m-1}\in \nulls \implies \text{FOLLOW}(Y_k)\supseteq\text{FIRST}(Y_m)~(1\le k\lt m\le n)
$$
$$
\def\nulls{\text{Nulls}}
Y_{k+1}\in \nulls \land \dots \land Y_{n}\in \nulls \implies \text{FOLLOW}(Y_k)\supseteq\text{FOLLOW}(X)~(1\le k\le n)
$$

であれば、要素を追加。

## LL(1) 言語

まず、LL(1)文法から生成される言語はLL(1)言語。しかし、LL(1)文法でなくてもLL(1)言語となる場合もある。

[^1]: $Y$の添字が$k-1$であることに注意。$n=1$のときはならばの仮定がなくなるので結論が成り立ち、$Y_1$が追加される。

## インタプリタ実装

インタプリタ実装のためのコード片を載せておく。データの定義は `syntax.ml` みたいな感じ。

```ocaml title="syntax.ml"
(* id *)
type id = string

(* 演算子 *)
type binOp = Plus | Mult | Lt | And | Or

(* 式 *)
type exp =
  | Var of id
  | ILit of int
  | BLit of bool
  | BinOp of binOp * exp * exp
  | IfExp of exp * exp * exp
  | LetExp of id * exp * exp

(* 値 *)
type exval =
  | IntV of int
  | BoolV of bool

(* 環境 *)
type environment = (id * exval) list

(* 例外 *)
exception Error of string
```

評価器のコードはこんな感じ。

```ocaml title="eval.ml"
let rec find x env =
  match env with
  | [] -> raise (Error (x ^ "was not found in the environment."))
  | (id, v) :: t -> if id = x then v else find x t

(* 式の評価 *)
let rec eval env = function
  | ILit i -> IntV i
  | BLit b -> BoolV b
  | Var x -> find x env (* 環境からxに束縛された値を探す *)
  | IfExp (e, e1, e2) ->
    let test = eval env e in
    match test with
    | BoolV true -> eval env e1
    | BoolV false -> eval env e2
    | _ -> raise (Error ("test must be bool."))
  | LetExp (id, e1, e2) ->
    let v1 = eval env e1 in
    let newenv = (id, v1) :: env in
    eval newenv e2;;
```
