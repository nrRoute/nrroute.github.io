---
title: 院試勉強20250728
created: 2025-07-28
prev: entrance-exam/20250727
next: entrance-exam/20250729
tags:
- computer-system
- programming-language
modified: 2025-07-31
---

# 計算機システム

## 記憶階層全般

### 時間的局所性

ある項目が参照された場合、その項目がまもなく再び参照される可能性が高い。

### 空間的局所性

ある項目が参照された場合、その項目の近くにある項目がまもなく再び参照される可能性が高い。

### ミス・ペナルティ

記憶回想のあるレベルでキャッシュミスしたときに、下位のレベルからブロックを取り出すのにかかる時間。

## キャッシュの方式

### ライト・スルー

データを書き込む際にキャッシュと記憶階層の次の下位レベルの両方を常に更新する方式。両者の間でデータが一貫していることがつねに保証される。
プロセッサの速度がかなり低下する可能性がある。

### ライト・バッファ

主記憶への書き込み待ちのデータを保持する待ち行列を持つ方式。主記憶の書き込み完了の速度が、プロセッサで生じる主記憶書き込みの発生頻度よりも低ければ、意味がない。

### ライト・バック

データを書き込む際はキャッシュ中のブロックを更新するだけにとどめ、ブロックを置き換えるときに更新された内容を記憶階層の下位レベルに書き戻す方式。
速いが、実装が複雑。

## 書き込み時の対応

ライト・スルー方式のキャッシュでミスが起きたときを考える。

### ライト・アロケート

キャッシュ内にブロックを割り当てる。最も一般的。メモリからブロックが取り出され、そのブロックの適切な部分が上書きされる。

### ノー・ライト・アロケート

メモリ中のブロックの該当部分が更新されるが、そのブロックはキャッシュには収められない。
OSがメモリ中のページをゼロクリアするときなど、キャッシュにデータを入れる必要がないときがあるため。

## マルチレベル・キャッシュ

キャッシュを1レベル追加して、DRAMアクセス時間（遅）とプロセッサのクロック周波数（速）の差を縮める。
1次キャッシュでミスが起これば、2次キャッシュを参照する。ここにデータがあれば、ミスペナルティは小さく済む。
単一のキャッシュを使用する場合と比べ、1次キャッシュではブロックサイズが小さく、2次キャッシュは大きい。ともにミスペナルティを減らすためである。

## ブロックサイズとミス率の関係

ブロックサイズが大きいと、空間局所性を活用してミス率を下げられる。また、データを相対的に効率よく転送できる。
逆にブロックサイズが大きすぎると、キャッシュ中に保持できるブロック数が少なくなり、ブロック間の競合が生じてミス率が上がる。
また、ブロックの転送時間が増大しミス・ペナルティが大きくなる。グラフにすると、下に浅い凸の形になる。

## 可用性 Availability

MTTF: 平均故障寿命 mean time to failure<br />
MTTR: 平均修復時間 mean time to repair <br />
とおくと、

$$
\text{可用性} = \frac{\text{MTTF}}{\text{MTTF}+\text{MTTR}}
$$

## 仮想記憶

主記憶と2次記憶（磁気ディスクなど）の間にある「キャッシュ」に相当するもの。

### ページ・フォールト

仮想記憶と2次記憶の間でのキャッシュミスに相当するもの。仮想記憶ではブロックを「ページ」という。

# 情報理論

## クラフトの不等式

TODO

## 情報源符号化定理

TODO

## いろいろな通信路

TODO

# プログラミング言語処理系

インタプリタ実装のためのコード片を載せておく。データの定義は `syntax.ml` みたいな感じ。

```ocaml title="syntax.ml"
(* id *)
type id = string

(* 演算子 *)
type binOp = Plus | Mult | Lt | And | Or

(* 式 *)
type exp =
  | Var of id
  | ILit of int
  | BLit of bool
  | BinOp of binOp * exp * exp
  | IfExp of exp * exp * exp
  | LetExp of id * exp * exp

(* 値 *)
type exval =
  | IntV of int
  | BoolV of bool

(* 環境 *)
type environment = (id * exval) list

(* 例外 *)
exception Error of string
```

評価器のコードはこんな感じ。

```ocaml title="eval.ml"
let rec find x env =
  match env with
  | [] -> raise (Error (x ^ "was not found in the environment."))
  | (id, v) :: t -> if id = x then v else find x t

(* 式の評価 *)
let rec eval env = function
  | ILit i -> IntV i
  | BLit b -> BoolV b
  | Var x -> find x env (* 環境からxに束縛された値を探す *)
  | IfExp (e, e1, e2) ->
    let test = eval env e in
    match test with
    | BoolV true -> eval env e1
    | BoolV false -> eval env e2
    | _ -> raise (Error ("test must be bool."))
  | LetExp (id, e1, e2) ->
    let v1 = eval env e1 in
    let newenv = (id, v1) :: env in
    eval newenv e2;;
```

なんかマジで苦しくなってきた。本当に受かるのか？
