---
title: 計算機アーキテクチャまとめ
created: 2025-07-31
tags:
- computer-architecture
- summary
modified: 2025-08-01
---

# 2進数の扱い

## 2の補数表現

絶対値表現からの変換はビットを反転させて1をたすだけ。
足し算引き算は2の補数表現同士ではそのまましてよくて、引き算の時に気をつけないといけないのは、最上位ビットで繰り下がりが発生した場合も、勝手にその上の桁を作って借りてきて良いというもの。
負の数同士を足して符号ビットが0になったり、正の数同士を足して符号ビットが1になったりすると、オーバーフローか計算ミス。
2の絶対値表現は、最上位ビットが符号ビットで、他は普通の2進数。

## 算術シフト

### 算術右シフト

2の補数表現の整数を右へ $k$ ビットずらす。最上位ビットの符号ビットをそのままコピーして、空いた左端に埋める。
最上位が0であれば0、1であれば1を埋めていく。下に溢れた数は捨てる。

:arrow_right: 符号拡張

### 論理右シフト

単純に全体を右にずらす。符号ビットもずらす。

## 例題
### 2019年A-7より

1. $10111000-11000111$
2. $10111000+10111000$
3. $11000111$ を算術右シフト

# パイプライン・ハザード

## 構造ハザード

一緒に実行される命令の組み合わせにハードウェアが対応できないために、命令を所定のクロック・サイクルで実行できない事態が発生すること。たとえば、メモリが1つしかないとき、メモリアクセスを伴う命令と次の命令のフェッチが同時に行われる可能性がある。
命令とデータのメモリを分けると回避できる。

## データ・ハザード

命令の実行に必要なデータがまだ利用可能になっていないために、予定している命令を実行できない状況が発生すること。フォワーディングなどで回避できる。

# 分岐予測

## 制御ハザード

パイプライン処理において、分岐が存在するため、フェッチ済みの物理的に後続する命令が実行すべき命令か否か判断できず、所定のクロック・サイクル内では命令を実行できない状況。
分岐命令をロードしたとき、実際に条件部を評価してPCを動かす前に次の命令を読み込んでおり、分岐が成立した場合にその命令を破棄する（ストールを流す）必要がある。
というか、**分岐命令の結果がわかるのがMEMステージで、そこまでは次の命令を実行すべきかわからず、ストール（バブル）を流す必要があるので、想定より実行に時間がかかる**という話。
分岐予測によって、このストールを減らすことができる。分岐予測の方法には成立分岐予測、不成立分岐予測、2ビット予測などがある。

## 成立・不成立分岐予測

静的分岐予測の一種。条件分岐命令で常に分岐する・しないと仮定する方法。予測と結果が合えば、ペナルティが少なく済む。

## 動的分岐予測

実行時の情報を使用して実行時に分岐を予測すること。

### 分岐履歴バッファ

分岐履歴テーブル。分岐予測のための小さなメモリ。分岐命令のアドレスの下位部分でインデックス付けされ、その分岐命令が最近成立したか否かを示す情報が何ビットか記録される。

## 2ビット予測

![2ビット予測器の状態遷移図](../../assets/2bit-branch-predictor.svg)

# 単精度浮動小数点

IEEE754で定められている形式についてまとめる。倍精度、半精度については、ビット数が半分になって、それに合わせて仮数部、指数部のビット数が少なくなり、指数部の下駄の数が変わる。

まず、2進の小数は $(-1)^s \times c \times 2^q$ と表せる。それぞれの文字について詳しく見ていく。

## $s$: 符号 sign

正負の符号は先頭の1ビットで管理する。

## $c$: 仮数部 fraction

1.xxx という正規化された形で表される。後ろの23ビットで表す。正規化されている場合、先頭がかならず1になるので、仮数部には xxx のみを格納すればよく、実質的に24ビット精度になっている。これを**けち表現**という。
問題を解く際、10進からの変換では、先頭の1を省略することを忘れないこと。浮動小数点形式どうしの足し算や引き算の問題では、小さい方の小数の省略されている1を戻して計算すること。

## $q$: 指数部 exponent

実際の指数に127を足した数が格納される。これは、$q$ が負になるときに、指数部も $s$ も符号をもつことになり、ややこしいため。この表現方法を**下駄履き表現**という。
問題を解く際、10進から変換するときは127を足して、浮動小数点形式からの変換では127を引くこと。

## エンコード規則

単精度のときを考える。

指数|仮数|内容
-|-|-
0|0|0
0|0以外|不正規化数
1-254|任意|浮動小数点数
255|0|無限大
255|0以外|NaN


## 例題

-9.375を変換する。

まず、9.375を2進で表すと、1001.011である。符号も含めて正規化すると、$-1.001011 \times 2^{3}$ である。符号は1、仮数部は001011、指数部は3+127=130（つまり1000_0010）<br />
よって、答えは

```
1__1000_0010__0010_1100_0000_0000_0000_000
```

# 符号拡張

最上位の符号ビットを拡張するビット分左に並べる。論理右シフトの逆みたいな感じ。

# 命令

## MIPSのアドレッシングモード

命令の操作対象の指定と、主記憶のデータの参照の方法について。

### 即値

命令中に指定した即値をオペランドとする。

### レジスタ

命令中で与えられた番号のレジスタの値をオペランドとする。オペランドにレジスタをとる。

### ベース相対

レジスタの値と即値の和のアドレスを参照する（データアドレッシング）。

### 擬似直接

命令中の下位26ビットとPCの上位ビットを連結したものがジャンプ・アドレスとなる。

### PC相対

PCと命令中に指定した定数との和によってアドレスを示す。現在のPCからどれだけ先（前）の番地にアクセスするかを指定する（データアドレッシング）。

## load/store architecture

命令セットをメモリアクセスをともなう命令と即値とレジスタのみがオペランドになる演算命令の2つにわける命令セットアーキテクチャ。

## 複数命令発行

複数命令を発行するプロセッサを実装する方式。

- 静的-: 多くの事柄が実行以前にコンパイラによって決定される。
- 動的-: 多くの事柄が実行時にプロセッサにより決定される。

## 投機実行

コンパイラまたはプロセッサが命令の実行結果を事前に予想し、他の命令の実行の障害になるような依存関係を早期に排除できるようにする方式。

## VLIW

Very Long Instruction Word。独立とされた多くの操作を単一の長い命令内に詰め込む方式の命令セット・アーキテクチャ。

## ループ展開

配列にアクセスするループの性能を改善する技法。ループ本体のコピーをいくつも作成し、ループであれば順に繰り返される命令をまとめてスケジューリングする。

## スーパスカラ

1クロック・サイクルで複数命令をプロセッサが実行できるようにしたパイプライン技法。命令の選択は実行中に行われる。

# 例外

「割込み」ともいう。プログラムの実行を妨げる予定外の事象。たとえばオーバーフロー検出に用いられる。

## 割込み

プロセッサの外部から発生した例外（すべての例外に関して割込みという場合もある）。

# 加算器

$$
C_i = a_i b_i + (a_i \xor b_i) C_{i-1} \\
S_i = (a_i\xor b_i) \xor c_{i-1}
$$

## 桁上げ先見加算器

漸化式を展開して回路を組む。

## 桁上げ保存加算器

## 桁上げ選択加算器
